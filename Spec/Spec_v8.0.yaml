workflow:
    inputs:
        children : 
            type : SequenceReadArchivePaired
            forward-pattern: "regex"
            backward-pattern: "regex"

        parent : 
            type : SequenceReadArchivePaired
            forward-pattern: "regex"
            backward-pattern: "regex"
    steps:
        qc:
            samples: children, parent
            inputs:
                fastq: 

        align:
            samples: children, parent
            inputs:
                paired-read:
            outputs:
                aligned-file:
            
        #output of align is 1 file named aligned-file
        #In reality it is generating: children.align.aligned-file[] | parent.align.aligned-file[]
        
        #Next step takes only one file. 
        #since each output of a processing instance can be plugged into convert, convert is now part of the thread
        
        convert:
            inputs:
                input:
            outputs:
                out:

        #one file generated can flow into next
        
        sort:
            inputs:
                file:
            outputs:
                sorted:
        
        #one file generated can flow into next

        index:

        
        dedup:
            inputs:
                file:
            outputs:
                dups_output:
                dups_metrics:
                
        # !!!!!Mismatch - Next step takes one file, which to plug in?????        
        #
        #    - Explicit mapping
        #    - Implicit name matching
        #    - Type matching
            
        #    Or fail with clear message 
                
        index-dedup:
            inputs:
                input: dedup/dups_output
         
        # We can have a convention that of not path then 
        # A global match
        # Or a match form last one on the flow chain
        
        #Failing with error if ambiguius
         
        metrics:
            inputs:
                input: dups_output
                
            outputs:
                output:
                historgam:
                
        coverage:
            inputs:
                input: dups_output
                
        #output flows into next
                    
        summarize-genomecov:
        
        
        merge-parents: 
            samples: parents
            inputs: 
                input: deups_output # This indicates a gather on a thread related to the sample
            outputs:
                merge:
        
        
        Q: If we omit the "step" name in input how do we identify original or last step
        Ans: If we omit it is the output of the last step of a thread on that sample. Or original if no processing occured in between.
             AKA last transformed state.
             
             Or specified explicitly "parent" plugin the original.
             Or convention to use input
             
        
        gridss:
            samples: children
            inputs:
                main-input: dedup/dups_output OR dups_output
                parent-merge: merge # Convention is to look in chain up. 
        
        
        diff:
            samples: children, parent
            inputs: 
                src: input 
                dst: some-step-above
                
                
        megamerge:
            inputs:
                proc1-parents: step5/file1
                proc1-children: step7/file33
                proc2-parents: step5/file1
                proc2-children: step7/file33
            
            
            
            [output] <- last matching output up the chain. Can be output of special "input" step
                A presence of sample may dicate the chain
                See gridss up
            
            [step]/[output] <- output of last matching step. Alias is considered.
            [sample]/[step]/[output] <- Full path
            
            Note: input/children <- special step / output
            
            In the case above:
            
            1. steps need to disambiguate. Use alias.
            
                        
        megamerge:
            inputs:
                original-parents: input/parents
                original-children: input/children
                proc1-parents: parent/step5/file1
                proc1-children: children/step7/file33
                proc2-parents: parent/step5-alias/file1
                proc2-children: children/step7-alias/file33

            
            



        NOTE:
        
            Disambiguation of step using alias
            
            qc:
                alias: proc1-qc
                
            qc:
                alias: proc2-qc
            
        
#####################################################################################        
        
        
        
        
        merge-parents: 
            inputs:
                samples: parents
                input: deups_output # This indicates a gather on a thread
                
                
                #Note:
                
                #parent in itself could mean the global data type
                #If we set a convention that parent should indicate the last thread usage
                
                #The the advantage is:
                #    - "parent[dups_output]" could be used with the help of convention C2
                #    - "parent" could be used in conjunction with name mapping
                
                #The problem is:
                #   - How do we refer to global parent? Example "Diff". "global.parent"
                #   - If there are two instances of threading using parent data set 
                #     and the gater is not immediate? 
                # 
                
            outputs:
                merge:
        
        
        
        
        diff:
            inputs:
            samples: parents
                originl: input
                transformed:
                    data: parents
                    source: dedup
                    
        random:
            inputs:

                1: parents
                2: 
                    sample: parent
                    source: step
                
                3: children
                4: 
                    sample: children
                    source: step
                
            
        
            samples: parents
            first: input
            second: merge
            
            
            Scatter? of children
            
        gridss: <- The step implementation will dictate if it scatters on an input
            inputs:
                children: children[dedup/dups_output]
                parent-merge: merge # Convention is to look in chain up. 
        
        
        report:
        archive:
        upload:


        mega-merge:
            inputs:
                proc1-parents:
                    data : parents
                    source: 
                proc1-children:
                    data : children
                    source: 
                proc2-parents:
                    data : parents
                    source: 
                proc1-children:
                    data : children
                    source: step name / alias
            
        # Multiple steps with same name needs to be disambiguate with alias    
    


To reduce syntax can we do:

For input, i.XXXXX
For output o.XXXX









Conventions:

C1: Steps are assumed in order unless otherwise proven by input dependency

C2: In mapping if not path then plug in global or output form immediate step

            
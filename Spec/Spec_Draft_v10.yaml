workflow:
    inputs:
        children : 
            type : SequenceReadArchivePaired
            forward-pattern: "regex"
            backward-pattern: "regex"

        parent : 
            type : SequenceReadArchivePaired
            forward-pattern: "regex"
            backward-pattern: "regex"
            
    #Notes:
    # 1. Inputs is a special step whose output are the defined symbols with their types
    # 2. Types have corresponding implementation in the translator framework to encapsulate their behaviour
    # 3. A registry mechanism allows types to be added in the framework
    
    
    steps:
    
        #Notes:
        # 1. A step corresponds to a pipeline execution step.
        # 2. The step has name, method, Alias
        # 3. In absence of "method" attribute, the name is used as method.
        # 4. A step can also have alias. The alias can be used to disambiguate steps where
        #    same method is used in multiple step. Explained later through example. 
    
        # 5. samples attribute defines a list of inputs where independent threads of execution 
        #    of the step happens for each input in the list
        
        #6.  Each "method" has corresponding implementation in the translator framework
        
        #7. A registry mechanism allows methods to be added in the framework
        
        #8. A setp/method has input and output parameters. 
        #   The inputs and outputs section specifies mapping.
        
        #9. A step/method can choose to scatter over an input parametr.
        #.  If scatteer is specified then the type instance mapped must support appropriate interface to provide array to scatter over
        
        
        qc:
            samples: children, parent
            inputs:
                fastq: 
                
                
        # In the above example a step named "qc" is executed using "qc" method.
        # The samples dicate two independent thread of execution corresponding each sample set
        # It has 1 input parameter "fastq"
        
        # How do we map input parameter?
        
        #Conventions:
        
        # [output] <- last matching output up the chain. Can be output of special "input" step
        # [step]/[output] <- output of last matching step. Alias is considered.
        # [sample]/[step]/[output] <- Full path if there are threads based in sample
        
        #If nothing is provided
        
        #Then convention of implicit
        
        # A "name"" match is performed to find the last matching output
        # A type match is performed to find the last matching output
        # "sample" also creates an implicit scope to make data available (see example below)
         
        

        align:
            samples: children, parent
            inputs:
                paired-read:
            outputs:
                aligned-file:
                
        # The samples indicate two independent thread
        # The samples also create implicit scope where "children" or "parent" is available 
        # in the input mapping search chain.
        # Example:
        # In the "children" thread, the mapping for input "paired-read" is search scope has
        # "children" data in implicit scope and global children data in global scope.
        # Given the data tupe matching it is mapped to children in immediate scope.
        
        Is this step is in seq with threads of "qc"?
        
        
        
         
        
        
        
         
        
        
        
        
        
            
        #output of align is 1 file named aligned-file
        #In reality it is generating: children.align.aligned-file[] | parent.align.aligned-file[]
        
        #Next step takes only one file. 
        #since each output of a processing instance can be plugged into convert, convert is now part of the thread
        
        convert:
            inputs:
                input:
            outputs:
                out:

        #one file generated can flow into next
        
        sort:
            inputs:
                file:
            outputs:
                sorted:
        
        #one file generated can flow into next

        index:

        
        dedup:
            inputs:
                file:
            outputs:
                dups_output:
                dups_metrics:
                
        # !!!!!Mismatch - Next step takes one file, which to plug in?????        
        #
        #    - Explicit mapping
        #    - Implicit name matching
        #    - Type matching
            
        #    Or fail with clear message 
                
        index-dedup:
            inputs:
                input: dedup/dups_output
         
        # We can have a convention that of not path then 
        # A global match
        # Or a match form last one on the flow chain
        
        #Failing with error if ambiguius
         
        metrics:
            inputs:
                input: dups_output
                
            outputs:
                output:
                historgam:
                
        coverage:
            inputs:
                input: dups_output
                
        #output flows into next
                    
        summarize-genomecov:
        
        
        merge-parents: 
            samples: parents
            inputs: 
                input: deups_output # This indicates a gather on a thread related to the sample
            outputs:
                merge:
        
        
        Q: If we omit the "step" name in input how do we identify original or last step
        Ans: If we omit it is the output of the last step of a thread on that sample. Or original if no processing occured in between.
             AKA last transformed state.
             
             Or specified explicitly "parent" plugin the original.
             Or convention to use input
             
        
        gridss:
            samples: children
            inputs:
                main-input: dedup/dups_output OR dups_output
                parent-merge: merge # Convention is to look in chain up. 
        
        
        diff:
            samples: children, parent
            inputs: 
                src: input 
                dst: some-step-above
                
                
        megamerge:
            inputs:
                proc1-parents: step5/file1
                proc1-children: step7/file33
                proc2-parents: step5/file1
                proc2-children: step7/file33
            
            
            
            [output] <- last matching output up the chain. Can be output of special "input" step
                A presence of sample may dicate the chain
                See gridss up
            
            [step]/[output] <- output of last matching step. Alias is considered.
            [sample]/[step]/[output] <- Full path
            
            Note: input/children <- special step / output
            
            In the case above:
            
            1. steps need to disambiguate. Use alias.
            
                        
        megamerge:
            inputs:
                original-parents: input/parents
                original-children: input/children
                proc1-parents: parent/step5/file1
                proc1-children: children/step7/file33
                proc2-parents: parent/step5-alias/file1
                proc2-children: children/step7-alias/file33

            
            



        NOTE:
        
            Disambiguation of step using alias
            
            qc:
                alias: proc1-qc
                
            qc:
                alias: proc2-qc
            
        
#####################################################################################        
        
        
        
        
        merge-parents: 
            inputs:
                samples: parents
                input: deups_output # This indicates a gather on a thread
                
                
                #Note:
                
                #parent in itself could mean the global data type
                #If we set a convention that parent should indicate the last thread usage
                
                #The the advantage is:
                #    - "parent[dups_output]" could be used with the help of convention C2
                #    - "parent" could be used in conjunction with name mapping
                
                #The problem is:
                #   - How do we refer to global parent? Example "Diff". "global.parent"
                #   - If there are two instances of threading using parent data set 
                #     and the gater is not immediate? 
                # 
                
            outputs:
                merge:
        
        
        
        
        diff:
            inputs:
            samples: parents
                originl: input
                transformed:
                    data: parents
                    source: dedup
                    
        random:
            inputs:

                1: parents
                2: 
                    sample: parent
                    source: step
                
                3: children
                4: 
                    sample: children
                    source: step
                
            
        
            samples: parents
            first: input
            second: merge
            
            
            Scatter? of children
            
        gridss: <- The step implementation will dictate if it scatters on an input
            inputs:
                children: children[dedup/dups_output]
                parent-merge: merge # Convention is to look in chain up. 
        
        
        report:
        archive:
        upload:


        mega-merge:
            inputs:
                proc1-parents:
                    data : parents
                    source: 
                proc1-children:
                    data : children
                    source: 
                proc2-parents:
                    data : parents
                    source: 
                proc1-children:
                    data : children
                    source: step name / alias
            
        # Multiple steps with same name needs to be disambiguate with alias    
    


To reduce syntax can we do:

For input, i.XXXXX
For output o.XXXX









Conventions:

C1: Steps are assumed in order unless otherwise proven by input dependency

C2: In mapping if not path then plug in global or output form immediate step

            
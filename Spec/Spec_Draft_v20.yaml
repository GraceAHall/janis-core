workflow:
    inputs:
        children : 
            type : SequenceReadArchivePaired
            forward-pattern: "regex"
            backward-pattern: "regex"

        parent : 
            type : SequenceReadArchivePaired
            forward-pattern: "regex"
            backward-pattern: "regex"
            
    #Notes:
    # 1. Inputs is a special step whose output are the defined symbols with their types
    # 2. Types have corresponding implementation in the translator framework to encapsulate their behaviour
    # 3. A registry mechanism allows types to be added in the framework
    
    
    steps:
    
        #Notes:
        # 1. A step corresponds to a pipeline execution step.
        # 2. The step has name, method, Alias
        # 3. In absence of "method" attribute, the name is used as method.
        # 4. A step can also have alias. The alias can be used to disambiguate steps where
        #    same method is used in multiple step. Explained later through example. 
    
        # 5. samples attribute defines a list of inputs where independent threads of execution 
        #    of the step happens for each input in the list
        #.   inputs/sample-name specifies output of special step inputs
        #.   sample-name associates a step to an existing thread of processing on that sample set
        #.   If no existing thread then it is equal to inputs/sample-name 
        
        
        
        #6.  Each "method" has corresponding implementation in the translator framework
        
        #7. A registry mechanism allows methods to be added in the framework
        
        #8. A setp/method has input and output parameters. 
        #   The inputs and outputs section specifies mapping.
        
        #9. A step/method can choose to scatter over an input parametr.
        #.  If scatteer is specified then the type instance mapped must support appropriate interface to provide array to scatter over
        
        
        qc:
            samples: children, parent #Same as inputs/children, inputs/parent
            inputs:
                fastq: 
                
                
        # In the above example a step named "qc" is executed using "qc" method.
        # The samples dicate two independent thread of execution corresponding each sample set
        # It has 1 input parameter "fastq"
        
        # How do we map input parameter?
        
        #Conventions:
        
        # [output] <- last matching output up the chain. Can be output of special "input" step
        # [step]/[output] <- output of last matching step. Alias is considered.
        # [sample]/[step]/[output] <- Full path if there are threads based in sample
        
        #If nothing is provided
        
        #Then convention of implicit
        
        # A "name"" match is performed to find the last matching output
        # A type match is performed to find the last matching output
        # "sample" also creates an implicit scope to make data available (see example below)
         
        

        align:
            sample-set: children, parents #Refer to original inputs
            inputs: 
                ref: HUM
                paired-read: input
            outputs:
                aligned-file:
                
        # The samples indicate two independent thread
        # The samples also create implicit scope where "children" or "parent" is available 
        # in the input mapping search chain.
        # Example:
        # In the "children" thread, the mapping for input "paired-read", the search scope has
        # "children" data in implicit scope and global children data in global scope.
        # Given the data type matching it is mapped to children in immediate scope.
        
        # ------ Is this step (above) is in seq with threads of "qc"?
        
        #ANS: NO, The samples being output of input step makes them thread after input step
        
        
        #Steps are assumed to be in seq unless "sample" or Scattering" or "input mapping" indicates otherwise.
        
        #NOTE: For the step above "align" 
        # There are thow threads working on different samples
        # The step it self scatters on its input 


        #Uutput of align is 1 file named aligned-file
        #In reality it is generating: children.align.aligned-file[] | parent.align.aligned-file[]
        
        #Next step takes only one file. 
        #since each output of a align instance can be plugged into convert, convert is 
        #now part of the scattering
        
        convert:
            #Implicit samples: children, parent
            inputs:
                input:
            outputs:
                out:

        #one file generated can flow into next
        
        sort:
            inputs:
                file:
            outputs:
                sorted:
        
        #one file generated can flow into next

        index:

        
        dedup:
            inputs:
                file:
            outputs:
                dups_output:
                dups_metrics:
                
        # !!!!!Mismatch - Next step takes one file, which to plug in?????        
        #
        #    - Explicit mapping
        #    - Implicit name matching
        #    - Type matching
            
        #    Or fail with clear message 
                
        index-dedup:
            inputs:
                input: dedup/dups_output
         
        # Using the path convention established above, it cab be simplified to omit step name
        #Failing with error if ambiguius
         
        metrics:
            inputs:
                input: dups_output
                
            outputs:
                output:
                historgam:
                
        coverage:
            inputs:
                input: dups_output
                
        #output flows into next
                    
        summarize-genomecov:
        
        
        # Next step is noteworthy.
        # we want to gather (form the scatter happening) outputs for a specific thread of sample
        
        # The following step is associated with the thread that is processing parents 
        # The step/method will indicate a gather 
        merge-parents: 
            sample-set: parents
            inputs: 
                input: deups_output
            outputs:
                merge:

        gridss:
            sample-set: children
            inputs:
                child-input: dups_output
                parent-merge: merge # Convention is to look in chain up. 
        
      
      
      
        #------------------------------------------------------      
      
        diff:
            samples: children, parent
            inputs: 
                src: input #<- Original input children/parent depending on the thread
                dst: some-step-above #<- some step above 
                
        diff:
            samples: children, parent
            inputs: 
                src: input #<- Original input children/parent depending on the thread
                dst: 
                    step: some-step-above #<- some step above 
                    form: output-of-the-specified-step
                
                
                
        #--------------------------------------------------
        
        #Mega merge is a case where 2 set of samples go through 2 different case of processing steps
        # So 4 threads
        # And we want to feed them all to a step.
        # What is the mapping like?
        # if steps need to disambiguate. Use alias.
        
                
        megamerge:
            inputs:
                proc1-parents: 
                    sample: parent
                    step: proc1-step
                    from: output-of-specified-step
                proc1-children: step7/file33
                    sample: children
                    step: proc1-step
                    from: output-of-specified-step
                proc2-parents: 
                    sample: parent
                    step: proc2-step
                    from: output-of-specified-step
                
                proc2-children: 
                    sample: children
                    step: proc2-step
                    from: output-of-specified-step
            
                original-parent:
                    sample: parent
                    step: input
                
                original-children:
                    sample: children
                    step: input
            
        NOTE:
        
            Disambiguation of step using alias
            
            qc:
                alias: proc1-qc
                
            qc:
                alias: proc2-qc
            
        
#####################################################################################        
        
        

# Building Tools  
  
In this guide, we'll go through the process of building a tool wrapper.  

In this tutorial, we'l follow the process of wrapping a tool called:   

## Building the basic tool
 
First off, you need to decide where the tool should sit. If it's a unix tool, it should sit under the [`janis`](https://github.com/PMCC-BioinformaticsCore/janis) repository, if it's a bioinformatics tool: under the [`janis-bioinformatics`](https://github.com/PMCC-BioinformaticsCore/janis-bioinformatics) repo. If it's a new domain, contact `Michael Franklin`.

The general structure of the tools are:
```
janis_bioinformatics/
├── tool_producer/
│   ├── tool1_name/
│   │   ├── toolname_version1.py
│   └── tool2_name/
│   │   ├── toolname_version2.py
│   └── toolbase.py
│   ... other tools
```


So, place your file called: `$toolname_$version.py`in a subfolder of the tool name, in a subfolder of the manufacturer / producer of the tool.

### Inheriting from tool

For the example, we'll 



## Advanced versioning
_The section is under construction_.

## Piped and combining commands

When you want two tools to pipe data between them, unfortunately there's not a great solution. CWL allows you to tag inputs and outputs as [`streamable`](https://www.commonwl.org/v1.0/CommandLineTool.html#CommandInputParameter), however there are no workflow engines that properly support this.

For this reason, the current (less than impressive) suggestion is to manually pipe these together by adding a `|` (pipe) `ToolArgument` at certain positions, and ensure that the positions of the other `ToolInput`'s are explicit and sequential.

You will also need to add a `shell_quote=False` to the input of every `ToolInput` / `ToolArgument`, to ensure that when the command is generated by the CWL / WDL generators, there are no shell quotes added.

For example:
```python
# Piped tool command: 
#    tool1_baseCommand -inp1 ${tl1_input} | tool2_baseCommand -inp2 ${tl2_input}

class PipedTool(CommandTool):
    def inputs(self):
        return [
            ToolInput("tl1_input", String(), position=2, prefix="-inp1" shell_quote=False),
            ToolInput("tl2_input", String(), position=5, prefix="-inp2", shell_quote=False)
        ]
     
    def arugments(self):
        return [
            ToolArgument("tool1_baseCommand", position=1, shell_quote=False),
            ToolArgument("|", position=3, shell_quote=False),
            ToolArgument("tool2_baseCommand", position=4, shell_quote=False)
        ]
    # outputs and other required commands here
```

## Building a workflow as a tool

To ensure the documentation generator will automatically pick up the tool, we'll subclass the `Workflow` class, and place our inputs, steps, outputs and connections within the `__init__` method. For example, we're going to wrap `Bwa.Mem` + `SamTools.Sort` + `Gatk4.SortSam` in one workflow (see `bioinformatics/tools/common/alignsortedbam.py` for the full tool wrapping). But for example:

```python
from janis import Step, String, Input, Directory, Output
from janis_bioinformatics.data_types import Bam, BamBai, Fasta, Fastq, Sam  
from janis_bioinformatics.tools import BioinformaticsWorkflow  
from janis_bioinformatics.tools.bwa import BwaMemLatest  
from janis_bioinformatics.tools.gatk4 import Gatk4SortSamLatest  
from janis_bioinformatics.tools.samtools import SamToolsViewLatest  

class AlignSortedBam(BioinformaticsWorkflow):  
  
    def __init__(self):  
        super(AlignSortedBam, self).__init__("alignsortedbam", friendly_name="Align sorted BAM")  
  
        self._metadata.documentation = "Align sorted bam with this subworkflow consisting of BWA Mem + SamTools + Gatk4SortSam"  
        self._metadata.creator = "Michael Franklin"  
        self._metadata.dateCreated = "2018-12-24"  
        self._metadata.version = "1.0.0"  
  
        s1_bwa = Step("s1_bwa", BwaMemLatest())  
        s2_samtools = Step("s2_samtools", SamToolsViewLatest())  
        s3_sortsam = Step("s3_sortsam", Gatk4SortSamLatest())  
  
        s1_inp_header = Input("read_group_header_line", String())  
        s1_inp_reference = Input("reference", Fasta())  
        s1_inp_fastq = Input("fastq", Fastq())  
  
        s3_inp_tmpdir = Input("tmpdir", Directory())  
  
        o1_bwa = Output("o1_bwa", Sam())  
        o2_samtools = Output("o2_samtools", Bam())  
        o3_sortsam = Output("o3_sortsam", BamBai())  
  
        # Fully connect step 1  
        self.add_edges([  
            (s1_inp_header, s1_bwa.readGroupHeaderLine),  
            (s1_inp_fastq, s1_bwa.reads),  
            (s1_inp_reference, s1_bwa.reference)  
        ])    
        # fully connect step 2  
        self.add_edge(s1_bwa, s2_samtools.sam)   
        # fully connect step 3  
        self.add_edges([  
            (s2_samtools.out, s3_sortsam.input),  
            (s3_inp_tmpdir, s3_sortsam.tmpDir),  
        ])
 
        # connect to output  
        self.add_edge(s1_bwa, o1_bwa)  
        self.add_edge(s2_samtools, o2_samtools)  
        self.add_edge(s3_sortsam.output, o3_sortsam)
```


## Regenerating documentation

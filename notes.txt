---------------
--- GENERAL ---
---------------

CHANGES [TEST THESE]:
- WDL runtime duration removed

TODO 
- messages -> output file
- adapt translation units for new cwl parsed expressions
- address bugs 
- exceptions
    - samtools index (cwl -> wdl)
    - bwa index (cwl -> wdl)
    - cutadapt (cwl -> wdl)

------------------
--- CWL INGEST ---
------------------

misc
- can everything be both an object and a dict???? or is this just hints? just hints I think?

test suite
- edam formats 



---------------------
--- NXF TRANSLATE ---
---------------------

CWL -> NXF boofed 
- bwa index:
    whenever there is a Janis IfOperator the operator should be moved to prescript. See below. 
    script:
    """
    ${(${(${index_name != None}) ? index_name : sequences.simpleName})} \
    """

misc 
- Janis BasenameOperator -> Nextflow updated to no mods. This isn't doing normal janis unwrapping so didnt work.
- curly brace unwrapping boofed 

---------------------
--- WDL TRANSLATE ---
---------------------

misc 
- string + int interpolation? 
- inputs which are secondary files getting split into individual inputs (may be fine to leave as-is)
- remove runtime_seconds from inputs 

CWL -> WDL failed 
- bwa index 
- cutadapt paired 

CWL -> WDL Boofed
- samtools index: wtf is this?
    """
    set -e
    cat <<EOT >> 'inputs.bam_sorted'
    ~{bam_sorted}
    EOT
    samtools index \
    """


----------------
--- MESSAGES ---
----------------
CWL TODO
- main.py -> workflow parsing?
- VERSION
- EXPERIMENTAL
- FATAL

WORKFLOW 

### untranslated javascript ###
__TOKEN1__ = "$(inputs.myfile)"
__TOKEN2__ = "$(inputs.reads2)"

### errors / warnings ###
# inputs ---
# error:    [FALLBACK] reads1: parse failed. used fallback.
# warning:  [DATATYPE] reads2: WDL structs unsupported, used File instead.
# warning:  [DATAFLOW] reads2: unused input

# step1 ---
# error: [FALLBACK] step1:          parse failed. used fallback.
# error: [DATAFLOW] step1,reads2:   could not connect sources.

-----------------------
--- CWL UNSUPPORTED ---
-----------------------
- linkMerge
- WorkflowStepInput:valueFrom
- Any JS Expression using "self"
- [Workflow] InlineJavascriptRequirement:expressionLib?

------------------
--- CWL BOOFED ---
------------------

Can InputNodeSelectors be InputSelectors instead?

JS
- undefined vs null?

get basic functionality back online 
- workflow parsing
- InitalWorkDirRequirement

misc
- move entity ids to non-janis keywords
- ingestion.cwl.parsing.workflow.resolve_source()?

--------------
--- CWL JS ---
--------------

InitialWorkDirRequirement
- log to top of screen without __TOKEN__.
- eg: unparsed expression for file / directory staging: ${JS}


locations: CommandLineTool
- InitialWorkDirRequirement
- InitialWorkDirRequirement:Dirent:entry
- InitialWorkDirRequirement:Dirent:entryname
- InlineJavascriptRequirement:expressionLib

js expressions: translators 
- ensure correct unwrapping with new format. 

js expressions: self
- $(self.dirname)/$(self.nameroot)        # just weird?
- $(self.location.split('/'))
- $(self.location.split('/').slice(-1)[0])
- $(self.path.split('.').slice(0,-2).join('.'))
- $(self === "name" ? true : false)
- $(self === 'name' ? true : false).fastq
- $(self === "name" ? true : false).fastq$(inputs.index_name.ext)
- $(inputs.graph.nameroot).$(self)            # wtf?
- $(default_output_filename(".bw"))           # defined function call


-----------------
--- WDL-lexer ---
-----------------

Motivation: 
- wdl2cwl produces .sh script to run. Not very native CWL. 
- does a good job at interpreting local vars? look into how this is done. 
- if in some situations we can do native CWL parsing of shell, this is better? 
- should result in much more native looking CWL and Nextflow 

TODO
Command Parsing
- split text into commands: list[str | WDL.Expr.Placeholder]
- how do we handle local scope variables?
- decide how to parse command 
    - if there are multiple non-linux-env-var-set commands, use ShellCommandParser
    - else, use BasicCommandParser

BasicCommandParser
- remove comments
- remove env var set commands
- extract stdout redirects
- interpret position, prefix, separator, delim for each component (use galaxy as reference)
- each WDL.Expr.Placeholder needs to be evaluated (look at how wdl2cwl does it)

ShellCommandParser
- remove comments
- each line becomes ToolArgument
- each WDL.Expr.Placeholder needs to be evaluated (look at how wdl2cwl does it)




---------------------
--- USER COMMENTS ---
---------------------





----------------------------------
--- REDUCING TEST SUITE WEIGHT ---
----------------------------------

TIMES 

full suite: 58 sec (base), 215 sec (release)

test_commandtool: 2 sec
test_conditionals: 2 sec
test_generics_util: 2 sec
test_ingestion_cwl: 3 sec
test_ingestion_galaxy: 30 sec
test_ingestion_wdl: 2 sec
test_janis_translate: 81 sec
    - TestCwlToNextflow: 9 sec
    - TestCwlToWdl: 5 sec
    - TestFromGalaxy: 26 sec (base), 81 sec (release)
    - TestJanisToNextflow: 5 sec
    - TestJanisToWdl: 4 sec
    - TestPreprocessingModes: 3 sec
    - TestPreprocessingPrune: 3 sec
    - TestPreprocessingToBuilders: 3 sec
    - TestTranslationEndpoints: 15 sec
test_logger: 3 sec
test_metadata: 2 sec
test_operators: 2 sec
test_python_tool: 2 sec
test_receivefrom: 2 sec
test_secondary: 2 sec
test_stringbuilder: 2 sec
test_test_runner: 2 sec
test_tools: 2 sec
test_translation_cwl: 3 sec
test_translation_modules: 2 sec
test_translation_nextflow: 3 sec
test_translation_wdl: 2 sec
test_types: 2 sec
test_validateinputvalues: 2 sec
test_validators: 2 sec
test_workflow: 2 sec

LOCAL SUPPLY ALL TOOLSHED FILES FOR TEST 
- 

QUAY API CALLS -> DETERMINISTIC URI
- swap quay.io API calls to deterministic uri

MULLED BUILD -> MULLED HASH
- swap mulled build to mulled hash



general 
- it's all galaxy 
- all tools needed for workflow tests could be stored locally as package data. 
- need to reduce the amount of times tools are loaded. 
- reinstate cache with pickle

test_ingestion_galaxy.py (galaxy)
- most tests do full ingest(). 
- could store these on the class, then tests just check attributes on the janis entities.

test_janis_translate.py (galaxy)
- can have basic group, and extended group (CI)
- basic group just 2 tests: single tool, single workflow

pytest 
- `@pytest.mark.<markername>` to mark tests 
- `pytest -m <markername> -v` to run tests in group (change pytest command in github actions)
- "publish" github action stays the same
- "unit_tests" github action changed to using test group
- tried locally, works 




------------------------------------
--- GENERAL RUNTIME IMPROVEMENTS ---
------------------------------------

REMOVE QUAY.IO API CALLS 
- biocontainers uri can be directly calculated for single requirement tools
    eg.
    - <package version="3.1">samtools</package>
    -> quay.io/biocontainers/samtools:3.1

- mulled-hash can be used to calculate hash for tools
    - galaxy.tool_util.deps.mulled.util.v1_image_name()
    - galaxy.tool_util.deps.mulled.util.v2_image_name()
    eg
    - <package version="1.3.1">samtools</package>
    - <package version="1.1">bowtie2</package>
    - v2_image_name([build_target("samtools", version="1.3.1"), build_target("bowtie2", version="1.1")])
    - -> mulled-v2-ad09g8sag8dhw908gdwhw9a08dawjcaskfffsfa
    - quay.io/biocontainers/mulled-v2-ad09g8sag8dhw908gdwhw9a08dawjcaskfffsfa

can toolshed api calls be reduced / removed?
- may be able to reduce using cached wrappers for popular tools
- may be able to reduce (to almost zero) by knowing direct mapping of location to tool uris 

migrate galaxy tool xml parsing into janis
- few days work 
- looks doable





----------------------------
--- GALAXY DEPENDENCIES  ---
----------------------------

GALAXY DEPENDENCIES 
- creating MockApp
- from galaxy.util import unicodify


gxtool.inputs
gxtool.outputs
gxtool.name
gxtool.id
gxtool.version
gxtool.description
gxtool.raw_help
gxtool.creator
gxtool.requirements
gxtool.containers
gxtool.xrefs
gxtool.tool_source.xml_tree.findall('citations')
gxtool.command
gxtool.config_files
gxtool.tests


self.profile = float(tool_source.parse_profile())
self.id = tool_source.parse_id()






app = _get_app()
tool_source = get_tool_source(path)
    - tree, macro_paths = load_tool_with_refereces(xml_path)
    - XmlToolSource(tree, source_path=xml_path, macro_paths=macro_paths)
        - look at imports at top of file
tool = create_tool_from_source(app, tool_source)
    - Tool(config_file, tool_source, app, **kwds)
tool.assert_finalized() # may be unnecessary



Files with Galaxy dependencies 
- [✓] janis_core.ingestion.galaxy.gxtool.mock
- [✓] janis_core.ingestion.galaxy.gxtool.parsing.main
- [✓] janis_core.ingestion.galaxy.gxtool.parsing.param_flattener
    - used to check type of param (isinstance / case). 
    - can probably just change this to check attributes. 

Files which have been migrated to janis versions of galaxy code
- [✓] janis_core.ingestion.galaxy.gxtool.text.cheetah.blocks

Files which just used type hints which have been changed
- [x] janis_core.ingestion.galaxy.gxtool.parsing.inputs
- [x] janis_core.ingestion.galaxy.gxtool.parsing.outputs

remove these:
- [x] janis_core.ingestion.galaxy.gxtool.parsing.tests.custom_ops
- [x] janis_core.ingestion.galaxy.gxtool.parsing.tests.TestFactoryOld
- [x] janis_core.ingestion.galaxy.gxwrappers.scraping.wrappers




SMALL BUGS
- get_execution_paths() is returning 2 paths, when it should return 1
- annoying final UNKNOWN token end of cmdstmt
- resolve aliases doing weird shit  (hisat2) -x '$$reference_genome.index.fields.path'
- 'skeleton' mode should autotemplate tool inputs/arguments if they reference a process input
- filename types: 
    - always retain
    - janis_pipelines - CutAdaptBase_2
    - need pre-script for filename types
    - determine default
        - either "generated" or some form like ${output_prefix}-R1.fastq.gz
    - reference prescript redefinition in script 
- file type inputs - optional with default pointing to another tool input:
    - janis_pipelines - FastQCBase (extended):
      def read1 = read1.simpleName != params.NULL_VALUE ? read1 : ${reads1}
    - janis_pipelines - FastQCBase (regular):
      missing, but should be present! 



REGULAR MODE BUGS
0.  JANIS -> NEXTFLOW (BwaAlignment())
    - GETFASTQC_ADAPTERS should have 'read1_fastqc_datafile' as input
    - GETFASTQC_ADAPTERS should have 'read2_fastqc_datafile' as input

1.  CWL -> NEXTFLOW
    runtime inputs (runtime.cpu etc) should be kept in skeleton / regular mode

6.  ::GALAXY FEATURE::
    for options which appear in the templated command, mark these as mandatory.
    exceptions:
        - value is a galaxy param which we know is optional (in conditional param etc, or the param is marked optional)


TODO: TEST SUITE 100%
- nextflow
    - baseName vs simpleName?
- wdl 
    - miniwdl can't parse some WDL formats
    - wdl ingest: need to injest local variables (bwa.wdl Int totalSortThreads = select_first([sortThreads, estimatedSortThreads]))
    - mismatch secondary types
    - scatter on multiple inputs
    - nameroot operator - ask richard

NICETIES:
- galaxy 
    - make it faster
    - output collection especially with redirect is scuffed
    - picard_MarkDuplicates.xml: REMOVE_DUPLICATES='${remove_duplicates}' causing issues

TODO: RELEASE
- test cli
    - --galaxy-gen-images cmdline option etc
- all test-suites 
- all packages segregated as much as possible (ensure legacy compatibility)
- all packages build from pyproject.toml 
- ensure datatypes correctly segregated

FUTURE FEATURES
- prune_workflow() 
    - move static values to step.sources
- nextflow
    - Null values
        cwl subworkflow_test wf 
        looks weird: 
        OPTIONAL2(
            [].collect{ file(it) },         // in_file_arr
            file( params.NULL_VALUE ),      // in_file
            params.in_string_arr_optional,  // in_string_arr
            params.in_int_optional,         // in_int
            params.in_string_optional       // in_string
        )
- galaxy
    - annotation
        - move InputExtractor.add_uncaptured_inputs() to an annotation class.  
        - need to ensure not picking up gxparams which are only control params
    - repeat params (& conditional params?)
        - add support
        - cutadapt adapters argument
        - cutadapt library.type single?
    - command
        - which one is the main software command? 
        - future: create step for each software command, for non-linux software (mkdir, cp etc)?
    - select & when detection
        - mutually exclusive groups (cli args)
        - what to add to cmdstr 
        - .when() in janis? 
        - how will this appear in nextflow for tool translations? 
        - can we autoremove command compoennts for workflow translations?
            - would be only if all instances of the tool use have the same selects. 
            - others would need to be the same as tool translation. 
    - repeat block evaluation?
    

